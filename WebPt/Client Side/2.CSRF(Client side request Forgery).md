CSRF(client side request forgery)

Cross-Site Request Forgery (CSRF) is an attack that forces an end user to execute unwanted actions on a web application in which they are currently authenticated. With a little help of social engineering (such as sending a link via email or chat), an attacker may trick the users of a web application into executing actions of the attacker is choosing.


## Why this vulnerability arise:

1. ==CSRF vulnerabilities occur when vulnerable web apps simply trust the cookies sent by web browsers without further validation. if there is no same site cookie with secure.==
2. ==OTP is not required to update details (email, phone no. etc).==


### impact:

1. Unauthorized Actions
   It causes the victim to change  the email address on their account

2. Account Takeover

3. **Full System Compromise (If Victim is Admin)** If the victim is an administrator, the attacker can perform administrative actions


## How CSRF Works:

1. A user logs into a trusted website (e.g., a banking site) and their session cookie is stored in the browser.

2. While still logged in, the user visits a malicious website.

3. The malicious website sends a forged request (e.g., a money transfer) to the trusted site using the stored session cookie.

4. The trusted site executes the action, believing it was requested by the legitimate user.


## Injection point for CSRF

- CSRF can be GET based
   -Malicious action via URL parameters. (Easy to exploit via Link/Image).

- Post based
  -Malicious action via Form Body. (Requires auto-submitting form script).

- but not header based not cookies based (because user do not  have cookie access).

- `http://abcd.com/user/delete?id=123` (Agar victim is par click karega, to uska account delete ho jayega).



## How to Prevent CSRF:

1. CSRF Tokens:

    - Generate a random token on the server and embed it in each form.

    - Validate the token with each request.

   <input type="hidden" name="csrf_token" value="RANDOM_TOKEN" />

2. SameSite Cookies:

    - Use `SameSite=Strict` or `SameSite=Lax` in cookie settings to limit cross-site request usage.

3. Double Submit Cookies:

    - Send a token in both a cookie and a request header or body; server compares both.

4. User Interaction Validation:

    - Use CAPTCHA or other methods to ensure a human is making the request.

5. Re-authentication for Critical Actions:

    - Require the user to re-enter their password or use 2FA for sensitive operations.


## how to exploit:

use: capture the request by burp use engagement tool > generate csrf PoC and save file as csrf.html.

## testing on 4shared.com(using own account)

1. go to profile and edit profile page.
2. check for samesite will set to none (in inspect-storage-samesite) if set to none and secure set to false then there are chances of vulnerability.
3. capture the edit page request on burpsuite and use engagement tools-generate poc
4. edit the changes in field of names/email etc and save the code in .html format.
5. open the .html file (on web automatically) and submit the request. (in real world we send this file to victim if victim submit the request then we can make changes to his account like email change/fund transfer etc.
6. now refresh the edit page tab the changes will show there.

## ==We can try by removing csrf token or can change digit its occurs when server not checking CSRF token correctly==

## ==Change GET to POST or POST to GET etc. occurs when server not checking csrf token correctly==


- **Relevant Action:** Application ke andar koi sensitive action hona chahiye (e.g., Email change karna, Password badalna, Fund transfer).
    
- **Cookie-Based Session Handling:** Application sirf session cookies par trust karti hai user ko identify karne ke liye.
    
- **No Unpredictable Request Parameters:** Request ke parameters attacker ko pehle se pata hone chahiye. (Jaise: `email=hacker@mail.com`). Agar wahan koi "Secret Token" nahi hai jise attacker guess na kar paye, to CSRF ho jayega



## Lab #1 - CSRF vulnerability with no defenses

Vulnerable parameter - email change functionality

Goal - exploit the CSRF vulnerability and change the email address
creds - wiener : peter

Analysis:
In order for a CSRF attack to be possible : These must be satisfied.

- A relevant action - email change functionality(without OTP or any other verification)

- Cookie based session handling - session cookie(have session id)

- No unpredictable request parameters - satisfied (means CSRF token is not bind or available here with email)

## Lab #2 CSRF Conditions for Lab 2 (Token validation depends on request method)

- **A Relevant Action:**
    
    - **Satisfied:** The application allows changing the email address (a sensitive action).
        
- **Cookie-based Session Handling:**
    
    - **Satisfied:** The application uses session cookies to identify the logged-in user.
        
- **No Unpredictable Request Parameters:**
    
    - **Satisfied (By Manipulation):**
        
        - Normally, there **is** an unpredictable parameter (the CSRF Token) in the `POST` request.
            
        - **However**, when we switch the request to `GET`, the server stops asking for the token.
            
        - Therefore, in the `GET` request, there are **no unpredictable parameters** left. The attacker can predict everything.



#### **GET (Retrieve Data)**

- **Purpose:** Used to request or fetch data from a specified resource.
    
- **Visibility:** Parameters are sent in the **URL** string. (e.g., `page.php?id=5`).
    
- **Security:** NOT secure for sensitive data (passwords) because data remains in browser history and logs.
    
- **Caching:** Can be cached by the browser.
    
- **Analogy:** Like a **Postcard** (Data is visible on the outside).


#### **POST (Submit Data)**

- **Purpose:** Used to send data to the server to create or update a resource (e.g., Login, Form Submit).
    
- **Visibility:** Parameters are sent in the **Request Body**, not the URL.
    
- **Security:** More secure than GET for sensitive inputs, but still needs HTTPS (encryption) to be truly safe.
    
- **Caching:** Not cached by default.
    
- **Analogy:** Like a **Sealed Envelope** (Data is hidden inside).



## Lab 3 - CSRF where token validation depends on token being present

- **A Relevant Action:**
    
    - **Satisfied:** The application allows changing the email address (a sensitive action).
        
- **Cookie-based Session Handling:**
    
    - **Satisfied:** The application uses session cookies to identify the logged-in user.
        
- **No Unpredictable Request Parameters:**
    
    - **Satisfied (By Manipulation):**
        
        - Normally, there **is** an unpredictable parameter (the CSRF Token) in the request.
            
        - **However**, the server only validates the token **if the parameter is present** in the request body.
            
        - **Therefore**, if we completely **remove** the `csrf` parameter (key and value) from the request, the validation is skipped. Since the attacker can send a form without this parameter, there are no unpredictable parameters left.



## Lab 4 - CSRF where token is not tied to the user session

- **A Relevant Action:**
    
    - **Satisfied:** The application allows changing the email address.
        
- **Cookie-based Session Handling:**
    
    - **Satisfied:** The application uses session cookies to identify the user.
        
- **No Unpredictable Request Parameters:**
    
    - **Satisfied (By Swapping):**
        
        - Normally, the CSRF token is unpredictable to the attacker because they don't know the _victim's_ token.
            
        - **However**, the application accepts **any** valid token issued by the server, even if it belongs to a different user.
            
        - **Therefore**, the attacker can log in with their own account, obtain a valid token (which is known/predictable to them), and inject this token into the exploit. The server accepts this "borrowed" token as valid proof.

